# 综述

- 内容大多数来着《算法 第四版》这本黄色封面的书。
- 一些来自《剑指offer》和LeetCode上的题目
- 秦超老师的《算法面试通关40讲》
- 一些基础算法。
- 面试中常问和平时工作中常用方法。



ps：

大量的LeetCode题目待填



TODO

- [x] 默写4种基础排序算法，冒泡、交换、快排、堆排，分析复杂度

- [ ] 堆的数据结构

  理清楚多种树的概念，对比、总结

  - [ ] B+树的数据结构，增删改查
  - [ ] 红黑树的结构，增删改查+调平

- [x] 默写DFS、BFS

- [x] 二叉树遍历，前序、中序、后序

- [x] 队列、栈的互相转化，使用场景。（貌似在哪个专栏看到过某个中间件发消息的buff是一个栈（队列？）的结构，新的会覆盖旧的，如果新的超过了旧的就出问题了……）

- [x] DP

  跟着覃超的算法刷LeetCode
  
  

6 - 链表 - 206、24、141……

7  844

8 - 堆栈、队列 - 20

9 - 232 、225

11 - 703

12 - 239

哈希表

14 - 242

15 - 1

16 - 15、18

树

18 - 98

19 - 235、236 

22 - 50

23 - 169

25 - 122

DFS&BFS

28 - 102

29 - 104

30 - 22

32 - 51、52

33 - 36、37

二分

35 - 69

37 - 208

38 - 79、212

位运算

40 - 191

41 - 231、338

42 - 52

DP

45 - 70	

46 - 120

48 - 121、122、123、309、188、714

49 - 300

50 - 322

51 - 72

并查集

53 - 200

56 - 146





[随笔分类 - 算法研究](https://www.cnblogs.com/mcomco/category/1351341.html)



# 时间复杂度

这个东西的难点在于那些logn、nlogn、$2^n$复杂度的算法，还有一些经典的算法的复杂度求法，例如递归、回溯的复杂度如何计算。






# 基本数据结构

## 背包

## 队列&栈

> #### 有效的括号

LeetCode 20. [有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) 

思路：

- 括号总是成对出现的，遇见左边的括号就入栈，遇见右边的就出栈并检查是否匹配

- 遍历完成字符串，检查栈底是否为空



### ※ 用队列实现栈

LeetCode 225. [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

思路：

- 很明显，只使用单个的队列是肯定无法模拟栈的，要两个。
- 执行入栈操作时，就执行入队操作。
- 执行出栈操作时，由于栈是后进先出，所以把第一个队列中的数据按序出队列，再入第二个队列中，这样顺序就对了。



> #### 用栈实现队列

LeetCode 232. [ 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

思路：

- 与上题相同



## 链表

单向链表的数据结构

```java
 public class ListNode {
     int val;
     ListNode next;
     ListNode(int x) { val = x; }
 }
```



> #### 反转链表

LeetCode 206.  [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/comments/)

```java
public class Node {
    public int data;
    public Node next;
}

// 指针顺序
public ListNode reverseList(Node pHead){
    Node head = null;
    Node pNode = pHead; //指向当前结点的指针
    Node pPrev = null;	//指向当前结点的前一个结点的指针
    while(pNode != null){
        Node pNext = pNode.next;
        pNode.next = pPrev;
        pPrev = pNode; 
        pNode = pNext;
    }
   return pPrev;
}

//递归
public Node reverseList2(Node pHead){
	if(pHead == null || pHead.next == null){
		return pHead;
	}
    
	Node pNext = pHead.next; //保存当前结点的下一结点
	pHead.next = null; //打断当前结点的指针域，不然会照成循环引用
	Node reverseHead = reverseList2(pNext); //递归结束时reverseHead一定是新链表的头结点
	pNext.next = pHead; //修改指针域
	return reverseHead;
}

```



> #### 两两交换链表中的节点

LeetCode 24.  [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

思路：

- 创建一个虚拟的头指针，穿起来整个链表，虚拟头的下一个节点就是链表的开始节点。
- 之后就是链表删除节点、添加节点的思路。定义1号，2号，3号，3个指针，把2号删除，再把2号添加到1号的前面。此时前2个就完成，往后移动2格，继续后2个。

```java
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }

        ListNode virtualNode = new ListNode(0);
        virtualNode.next = head;
        ListNode pre = virtualNode;
        ListNode cur = head;
        
        while(cur != null && cur.next != null){
            ListNode first = cur;
            ListNode second = cur.next;
            ListNode third = cur.next.next;

            pre.next = second;
            second.next = first;
            first.next = third;

            pre = first;
            cur = third;
        }
        return virtualNode.next;
    }

    //递归
    public class Solution {
        public ListNode swapPairs(ListNode head) {
            if ((head == null)||(head.next == null))
                return head;
            ListNode n = head.next;
            // 每2个节点为一对，这样递归到最后，拿到最后一对的第一个节点（奇数），或者拿到null（偶数）
            head.next = swapPairs(head.next.next);
            n.next = head;
            return n;
        }
    }
```





>#### K 个一组翻转链表

LeetCode 25. [K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)





> #### 环形链表

LeetCode 141. [环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给定一个链表，判断链表中是否有环。

思路

- 暴力跑下去，检查是否能跑到null。
- 使用一个额外的set，用来存储已经遍历过的节点，每次遍历的时候去set里查找，这个时间复杂度O(n)，空间复杂度也为O(n)
- 快慢指针，照成遍历的速度差，只有有环那么两个指针就可能相遇。这也是O(n)的时间复杂度，不需要额外的空间。

```java
     // 借助额外的数据结构
     public boolean hasCycle(ListNode head) {
        Set<Integer> set = new HashSet<>();
        while(head != null){
          if(set.contains(head.val)){
            return true;
          }
          set.add(head.val);
          head = head.next;
        }
        return true;
    }

    //快慢指针
    public boolean hasCycle(ListNode head) {
        if(head == null || head.next == null){
            return false;
        }
        ListNode slow = head;
        ListNode fast = head.next;
        while(slow.val != fast.val){
            if(fast.next == null || fast.next.next == null){
                return false;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
```





> #### 环形链表II

LeetCode 142. [ 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

难点：

- 节点会出现重复的值，如：1，2，3，4，4，4，5，6....
- 节点没有长度限制，可能会出现重读的子串，如：1，1，1，2，3，4，2，3，4，.......2，3，4，5，6，7....
- 不允许修改给定的链表，否则可以给走过的路径打标记，把值统一改为-1
- 进阶：不用额外空间解决此题

思路：

- 还是两个指针，慢指针是一步步走，快指针是两步两步走，这样快指针是慢指针速度的2倍。
- 当第一次相遇时，可以确认有环，记录相遇点。
- 由于速度是两倍，再次相遇时








> #### 两个链表找相交

这是单链表，只有一个指向next结点的指针，不会有分叉。

1. 直接法

   采用暴力的方法，遍历两个链表，判断第一个链表的每个结点是否在第二个链表中，时间复杂度为O(len1*len2)，耗时很大。

2. hash计数法

   1. 遍历第一个链表，把每个结点存入hash表中。结束条件为到最后一个节点（无环）或Hash中该地址值已经存在（有环）。
   2. 遍历第二个链表，查询hash表，如果它在hash表中出现，则说明两个链表有共同的结点。
   3. 这个方法的时间复杂度为：O(max(len1+len2)；但同时还得增加O(len1)的存储空间存储哈希表

3. 先遍历第一个链表到他的尾部，然后将尾部的next指针指向第二个链表(尾部指针的next本来指向的是null)。这样两个链表就合成了一个链表，判断原来的两个链表是否相交也就转变成了判断新的链表是否有环的问题了：即判断单链表是否有环？

4. 仔细研究两个链表，如果他们相交的话，那么他们最后的一个节点一定是相同的，否则是不相交的。因此判断两个链表是否相交就很简单了，分别遍历到两个链表的尾部，然后判断他们是否相同，如果相同，则相交；否则不相交。假设第一个链表长度为len1，第二个问len2，然后找出长度较长的，让长度较长的链表指针向后移动|len1 - len2| (len1-len2的绝对值)，然后在开始遍历两个链表，判断节点是否相同即可。



[链表问题打卡汇总](https://mp.weixin.qq.com/s/GMsBhdPUZjFJ9RqCSYaQwg)



# 查找

二分查找

LeetCode [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int lo = 0, hi = nums.size() - 1;
        while (lo < hi) {
            int mid = (lo + hi) / 2;
            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo == hi && nums[lo] == target ? lo : -1;
    }
};

作者：LukeLee
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-jian-solution-by-lukelee/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  

```

解释：思路是一个二分，这个应该都想得到，关键是一下中间的`if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))`

> // 6 7 8 9 10 1 2 3 4 5
>
> 注意到原数组为有限制的有序数组（除了在某个点会突然下降外均为升序数组）
>
> 取任意i点
>
> - if nums[0] <= nums[i] 那么 nums[0] 到 nums[i] 为有序数组,那么当 nums[0] <= target <= nums[i] 时我们应该在 0−i 范围内查找；
>
> - if nums[i] < nums[0] 那么在 0−i 区间的某个点处发生了下降（旋转），那么 I+1 到最后一个数字的区间为有序数组，并且所有的数字都是小于 nums[0] 且大于 nums[i]，当target不属于 nums[0] 到 nums[i] 时（target <= nums[i] < nums[0] or nums[i] < nums[0] <= target），我们应该在 0−i 区间内查找。
>
>   上述三种情况可以总结如下：
>   nums[0] <= target <= nums[i]
>            target <= nums[i] < nums[0]
>                      nums[i] < nums[0] <= target

感觉第2点有点问题， 例子数组为6 7 8 9 10 1 2 3 4 5 ，假如num[i] = 2，那么nums[i] < nums[0]，在6与2之间确实发生了旋转。当target不属于 nums[0] 到 nums[i] 时，即target不属于6到2之间的数（target <= 2 < 6 or 2 < 6 <= target）。

这里需要统一一下表述，**当target不属于 nums[0] 到 nums[i] 时**，指的是不属于3 4 5这三个数，与位置无关的意思。而不是不属于6的位置到2位置之间的7 8 9 10 1这些数的意思。所以如果反过来表达**当target不属于 nums[i] 到 nums[0] 时**，会好一些。



> 所以我们进行三项判断：
>
> (nums[0] <= target)， (target <= nums[i]) ，(nums[i] < nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））
>
> 所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。
>
> 使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）
>

这里3个条件，需要满足其中2个，为什么？上面列了3个不等式，每行不等式拆开都有2个条件项，而且条件项组合起来刚刚好就是这3个，所以这3个条件里面任意2个为真，都能对上3行中的一行。






相比之下还是下面的逻辑更加好理解，这是上面那个解答的评论区里的

```c++

// 6 7 8 9 10 1 2 3 4 5
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() -1;
        
        while (l <= r)
        {
            int mid = (l + r) >> 1;
            if (target == nums[mid]) return mid;
            if (nums[l] <= nums[mid])
            {
                if (target >= nums[l] && target < nums[mid])
                    r = mid-1;
                else
                    l = mid+1;
            }
          	// 10 …… 2 …… 4
            else
            {
                if (target > nums[mid] && target <= nums[r])
                    l = mid +1;
                else
                    r = mid -1;
            }
        }
        return -1;
    }
};
```

先判断一下折点在中值的左边还有右边。

- 折点在右边，第一个if：类似于6 …… 9 …… 1或者 6 …… 8 …… 10
  - 如果目标值，在6与8之间，那么舍弃8之后的。
  - 否则舍弃6到8之间的
- 折点在左边，第二个if：类似于10 …… 2 ……4
  - 如果目标值在2到4之间则取右边
  - 否则取左边

这里的逻辑相对清晰，每次都是判断target值是否是在顺序的那一边，而不用去考虑有折点的那一部分。









## 符号表

## 树

> [2-3平衡树与B树的详细探讨](https://blog.csdn.net/zhizhengguan/article/details/108987419)
>
> [平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了](https://zhuanlan.zhihu.com/p/27700617)

### 二叉查找树

二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。B树称为**多路平衡查找树**，这里只考虑2路的。

**定义**：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] <= key[x]；如果y是x的右子树的一个结点，则key[y] >= key[x]。

1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树。
4. 没有键值相等的节点（no duplicate nodes）。
5. 所有结点存储一个关键字。



树节点定义

```java
public class BSTree<T extends Comparable<T>> {

    private BSTNode<T> mRoot;    // 根结点

    public class BSTNode<T extends Comparable<T>> {
        T key;                // 关键字(键值) 用来对二叉查找树的节点进行排序的
        BSTNode<T> left;      // 左孩子
        BSTNode<T> right;     // 右孩子
        BSTNode<T> parent;    // 父结点

        public BSTNode(T key, BSTNode<T> parent, BSTNode<T> left, BSTNode<T> right) {
            this.key = key;
            this.parent = parent;
            this.left = left;
            this.right = right;
        }
    }

}
```



主要操作： 包括WALK（遍历）、SEARCH（查找）、MINIMUM（最小关键字）、MAXIMUM（最大关键字）、SUCCESSOR（后继）、PREDECESSOR（前驱）、INSERT（插入）、DELETE（删除）等。重点就记录一下**遍历**、**查找**、**插入**、**删除**。



**遍历** - 遍历分为3种，**中序遍历**，**前序遍历**，**后序遍历**。

1. **前序遍历**

   若二叉树非空，则执行以下操作：
   ① 访问根结点；
   ② 先序遍历左子树；
   ③ 先序遍历右子树。

2. **中序遍历**

   ① 中序遍历左子树；
   ② 访问根结点；
   ③ 中序遍历右子树。

3. **后序遍历**

   ① 后序遍历左子树；
   ② 后序遍历右子树；
   ③ 访问根结点。



这样记忆，使用数组存储二叉树[根，左，右]，对应前中后



**查找**：在二叉搜索树中查找一个具有给定关键字key的结点，需要输入一个指向树根的指针x和一个关键字k，如果这个结点存在，则TREE-SEARCH返回一个指向关键字为k的结点的指针；否则返回NULL；有**递归和循环**2种实现方式实现。**时间复杂度为常数级O(h)**，最差的情况下等于树的高度h。

具体查找过程为：

① 从树根开始查找，并沿着这棵树中的一条简单路径向下进行；
② 若树为空树，则查找失败，返回；
③ 对于遇到的每个结点x，若关键字k等于结点x的关键字，查找终止，返回指向结点x的指针；
④ 若关键字k小于结点x的关键字，则查找在x的左子树中继续（根据二叉搜索树的性质，k此时不可能在右子树中）；
⑤ 对称地，若关键字k大于结点x的关键字，则查找在x的右子树中继续（k此时不可能在左子树中）；
⑥ 若查找至叶子结点后仍未匹配到相等的关键字，则关键字为k的结点不存在，返回NIL。

**插入**：

① 首先从树根开始遍历，沿树向下移动。

② 通过比较当前结点x的关键字与待插入结点z的关键字大小，来决定向左或向右移动。

③ 当移动到空节点时，就找到了节点z要放置的位置。

**在插入新结点后，新结点总是作为一个新叶子结点而存在的**

**删除**：

1. 如果z没有孩子结点，那么只是简单地将它删除，并修改它的父结点，用null节点作为孩子来替换z；
2. 如果z只有一个孩子，那么将这个孩子提升到树中z的位置上，并修改z的父结点，用z的孩子来替换z；
3. 如果z有两个孩子，那么找z的后继y，并让y占据树中z的位置。z的原来右子树部分成为y的新的右子树，z的原来左子树部分成为y新的左子树。这里要注意，z的后继y一定在z的右子树中，并且没有左孩子。利用z的后继y替换z，又细分为以下两种情况：

   3.1 如果y是z的右孩子，那么直接用y替换z，并保留y的右子树（y没有左子树）；

   3.2 如果y不是z的右孩子，那么先用y的右孩子替换y（y没有左孩子），然后再用y替换z。



[深入学习理解二叉搜索树（附详细讲解与实例分析）](https://blog.csdn.net/qq_21396469/article/details/78419609)

[二叉查找树(二)之 C++的实现](https://www.cnblogs.com/skywang12345/p/3576373.html)



如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；



#### ※ 验证二叉搜索树

 LeetCode [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

非常重要的一道题，要求要熟练的掌握出前中后3种图遍历的写法，熟练的掌握BFS与DFS的递归与迭代的写法。



初上手，非常的上头，直接去验了小的子树，导致右子树的左子树小于根，先来一个错误示范

```java
public static boolean isValidBST(TreeNode root) {
        boolean left = true;
        boolean right = true;
        if (root.left != null) {
            if (root.val <= root.left.val) {
                return false;
            }
            left = isValidBST(root.left);
        }
        if (!left){
            return false;
        }

        if (root.right != null) {
            if (root.val >= root.right.val) {
                return false;
            }
            right = isValidBST(root.right);
        }
        if (!right){
            return false;
        }

        return true;
    }
```



这道题要考虑到遍历的顺序，使用中序遍历，最终会得到一个左中右排序的数组，然后判断是否递增就可以了。

评论区的高赞，这个pre是递归的关键

```java
class Solution {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        if (!isValidBST(root.left)) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root.val <= pre) {
            return false;
        }
        pre = root.val;
        // 访问右子树
        return isValidBST(root.right);
    }
}


作者：sweetiee
链接：https://leetcode-cn.com/problems/validate-binary-search-tree/solution/zhong-xu-bian-li-qing-song-na-xia-bi-xu-miao-dong-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



再看看一位外国友人的使用双循环迭代的答案，以本题引出了几道题的解法，非常的给力。

```java
public boolean isValidBST(TreeNode root) {
   if (root == null) return true;
   Stack<TreeNode> stack = new Stack<>();
   TreeNode pre = null;
   while (root != null || !stack.isEmpty()) {
      while (root != null) {
         stack.push(root);
         root = root.left;
      }
      root = stack.pop();
      if(pre != null && root.val <= pre.val) return false;
      pre = root;
      root = root.right;
   }
   return true;
}

https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)
```





### 多路搜索树（**B-树**）

![B-树](截图/算法/B-树.JPG)



B树和B-tree 是同一个东西，没有B减树。B树属于多叉树又名**平衡多路查找树**。

- 平衡的意思是：   
  - **左边和右边分布均匀**
  - **从根节点，到每一个最底部的自己点，链路长度一致**
- 多路的意思是相对于二叉树而言的，**二叉树就是二路查找树，查找时只有两条路，而B-tree有多条路，即父节点有多个子节点。**



**遍历**：从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果

命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为

空，或已经是叶子结点；



**特点**：

1. 关键字集合分布在整颗树中；

2. 任何一个关键字出现且只出现在一个结点中；

3. 搜索有可能在非叶子结点结束；

4. 其搜索性能等价于在关键字全集内做一次二分查找；

5. 自动层次控制；



**性能**：lgN



### 多路搜索树（**B+树**）

B+树是B-树的变体，也是一种多路搜索树：如一个3路的。



![B+树](截图/算法/B+树.JPG)



**遍历**：B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；



**特点**：

1. 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
2. 不可能在非叶子结点命中；
3. 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
4. 更适合文件索引系统；



### **B\*树**

是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；



![B星树](截图/算法/B星树.JPG)



就没看到哪里有用过。





### 平衡查找树（红黑树）

> 找到一个比较好的视频讲解[2020B站最详细红黑树结构-二叉树-哈希-B+树-HASH-平衡算法](https://www.bilibili.com/video/BV1tE411f7tP?p=3)，看视频是可以看懂的

红黑树（Red-Black Tree）是二叉搜索树（Binary Search Tree）的一种改进。我们知道二叉搜索树在最坏的情况下可能会变成一个链表（当所有节点按从小到大的顺序依次插入后）。而红黑树在每一次插入或删除节点之后都会花O（log N）的时间来对树的结构作修改，以保持树的平衡。也就是说，红黑树的查找方法与二叉搜索树完全一样；插入和删除节点的的方法前半部分节与二叉搜索树完全一样，而后半部分添加了一些修改树的结构的操作。



1. 每个节点或者是黑色，或者是红色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。  [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
4. 如果一个节点是红色的，则它的子节点必须是黑色的。也就是红色节点不能连续。但是黑色可以相连。
5. 新加入的节点默认为红色，如果为黑色，则会完美符合所有的约束，导致调平流程失效。
6. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
7. **红黑树的时间复杂度为: O(lgn)**



![红黑树](截图/算法/红黑树.jpg)





**预备知识**：左旋与右旋。

1. **左旋**：左旋的过程是将`x`的右子树绕`x`**逆时针旋转**，使得`x`的右子树成为`x`的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。

   直观来说，就是右边的树更大，然后转到左边。

2. **右旋**：右旋的过程是将`x`的左子树绕`x`**顺时针旋转**，使得`x`的左子树成为`x`的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。

![左旋右旋](截图/算法/左旋右旋.jpg)



**添加节点**：

1. **第一步: 将红黑树当作一颗二叉查找树，将节点插入。（也是通过不断比较大小，插入到合适位置）** 红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。
2. **第二步：将插入的节点着色为"红色"。**
3. **第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。**



新插入的节点总是设为红色的，所以如果父节点为黑色，就不需要修复，因为没有任何性质被改变，所以只有在父节点为红色节点时需要做修复操作。

修复又分三种情况：

1. 





**删除节点**：



//todo 待补充





[图解红黑树](https://www.jianshu.com/p/0eaea4cc5619)

[史上最清晰的红黑树讲解（上）](https://www.cnblogs.com/CarpenterLee/p/5503882.html)

[红黑树(一)之 原理和算法详细介绍](https://www.cnblogs.com/skywang12345/p/3245399.html)





-------------------

> ### 《算法》中的红黑树版本

这个准确的说是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。其中链接分为两种类型

1. 红链接将两个2-结点连接起来构成一个3-结点，确切的说将3-结点表示为由一条左斜的红色链接相连的连个2-结点。
2. 黑链接则是2-3树中的普通链接。



关于颜色

1. 指的是指向该结点的**链接**的颜色。
2. 约定空链接为黑色，也就是根结点的颜色是黑色的。



一种等价定义是含有红黑链接并满足下列条件的二叉查找树：

- 红链接均为左链接。
- 没有任何一个结点同时和两条红链接相连（巨大的不同）。
- 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑色链接数量相等。



用这种定义来描述红黑树的时，如果把红链接画平时，一颗红黑树就是一个2-3树。

数据结构代码描述：

```java
private static final boolean RED = true;
private static final boolean BLACK = false;

private class Node{
    Key key;
    Value val;
    Node left, right;
    int N;					//这棵子树中的结点总数
    boolean color;
}

private boolean isRed(Node x){
    if(x == null) return false;
    return x.color == RED;
}

private void flipColors(Node h){
    h.color = RED;
    h.left.color = BLACK;
    h.right.color = BLACK;
}
```



当在插入新的结点之后，可能会使得整棵树不符合红黑树的定义，这时就需要进行旋转操作，进行一定的改变，最终保持红黑树的有序性和完美平衡性。



旋转

根据定义`红链接均为左链接`，所以需要把红色右链接转化为**左链接**，这个操作叫做左旋。具体就是将用两个键中的较小者作为根结点变为将较大者作为根结点。实现将一个红色左链接转换为一个红色右链接的一个右旋转的代码是完全一样的，调换一下即可。一般来说是右边的链接进行左转，左转的链接进行右边；

```java
Node rotateLeft(Node h){
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x;
}

Node rotateRight(Node h){
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    h.N = 1 + size(h.left) + size(h.right);
    return x;
}
```



插入

插入操作分为几种情况，都要综合考虑。

> #### 1. 向单个2- 结点中插入新键

这个是最简单的情况，往一个单结点中插入一个新的。

- 如果值比原结点的值小，直接插到左边结束
- 如果值比原结点的值大，插到右边，进行一次左旋

最后可以看成是一颗单3- 结点的红黑树。



> #### 2. 向一颗双键树（即一个3-结点）中插入新键

这个要分为3种情况来说。

> **新插入的键大于原来的2个结点**

原本用红链接相连的2个2-结点看成是一个3-结点，那么直接插到根结点右边，变成了一个4-结点。由于4-结点是不允许的，需要进行处理，当然也可以看成是3个2-结点的树，由于存在了右边的红色链接，所以需要进行处理。

这个时候需要一个颜色转换。这样就变成了一颗3个2-结点的红黑树，不能说成是一颗4-结点的红黑树了。

颜色转换：

> 1. 转换一个结点的两个红色子结点的颜色。
> 2. 将父结点的颜色由黑色变成红色



>  **新插入的键小于原树中的2个结点**

原本用红链接相连的2个2-结点看成是一个3-结点，那么直接插到最左边，变成了一个4-结点。由于4-结点是不允许的，需要进行处理，当然也可以看成是3个2-结点的树，一颗只有左侧子树的单条链的树。由于产生了两条连续的红链接，所以需要把根结点进行右旋转。



> **新插入的键在原树中的2个结点中间**

这样又会产生两条连续的红链接，根结点连一条红色左链接接一条红色的右链接。这是要进行2次旋转，先进行一次左旋转，这样就变成了上一种情况了。



```java
public class RedBlackBST<Key extends Comparable<key>, value>{
    private Node root;
    private boolean isRed();
    private Node rotateRight(Node h);
    private Node rotateLeft(Node h);
    private void flipColors(Node h);
    private int size();
  
    
    public void put(Key key, Value value){
        //查找key，如果存在则更新，否则为他新建一个结点
        root = put(root, key, value);
        root.color = BLACK;
    }
    
    public Node put(Node h, Key key, Value value){
        if (h == null) {
            return new Node(key, val, 1, RED);
        }
        
        int cmp = key.compareTo(h.key);
        if (cmp < 0){
            h.left = put(h.left, key, value);
        }else if(cmp > 0){
            h.right = put(h.right, key, value);
        }else{
            h.val = value;
        }
        
        //把任意含有红色右链接的3-结点向左旋转
        if(isRed(h.right) && !isRed(h.left)){
            h = rotateLeft(h);
        }
        
        //将临时的4-结点中两条连续红链接中的上层链接向右旋转
        if(isRed(h.left) && isRed(h.left.left)){
             h = rotateRight(h);
        }
        
        //颜色转换并且把红色结点向上传递
        if(isRed(h.left) && isRed(h.right)){
             h = flipColors(h);
        }
        
        h.N = size(h.left) + size(h.right) + 1;
        return h;
    }
    
}
```



删除

更加复杂的操作，目前没有遇见哪家公司要求手写或者考到了红黑树删除的。

//todo



各种符号表实现的性能总结

|                      | 最坏 | 最坏 | 平均 | 平均 |      |
| -------------------- | ---- | ---- | ---- | ---- | ---- |
|                      | 查找 | 插入 | 查找 |  插入    | 是否支持有序性操作 |
| 顺序查找（无序链表） | N | N | N/2 | N | 否 |
| 二分查找（有序数组） | lgN | N | lgN | N/2 | 是 |
| 二叉树查找（BST）    | N | N | 1.39lgN | 1.39lgN | 是 |
| 2-3树查找（红黑树）  | 2lgN | 2lgN | 1.00lgN | 1.00lgN | 是 |



- B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；
- B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
- B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点
  中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
- B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；





[B树，B-树，B*树，B+和红黑树的区别](https://blog.csdn.net/Beyond_2016/article/details/81202511)





### 平衡二叉树（AVL树）

**AVL树（Adelson-Velsky-Landis Tree）**是最先发明的自平衡二叉查找树，平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构；在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为**高度平衡树**。增加和删除可能需要通过一次或多次[树旋转](https://baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC)来重新平衡这个树。AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis，他们在1962年的论文《An algorithm for the organization of information》中发表了它。



**特点：**

1. 本身首先是一棵二叉搜索树。

2. 带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。



[红黑树与AVL树，各自的优缺点总结](https://www.jianshu.com/p/37436ed14cc6)



> ## 计算机科学中的树

| 二叉树 | ▪ [二叉树](http://baike.baidu.com/view/88806.htm)    ▪ [二叉查找树](http://baike.baidu.com/view/389459.htm)    ▪ [笛卡尔树](http://baike.baidu.com/view/6667519.htm)    ▪ [Top tree](http://baike.baidu.com/searchword/?word=Top%20tree&pic=1&sug=1&enc=utf8)     ▪ [T树](http://baike.baidu.com/searchword/?word=T%E6%A0%91&pic=1&sug=1&enc=utf8) |
| ------ | ------------------------------------------------------------ |
|        |                                                              |

| 自平衡二叉查找树 | ▪ [AA树](http://baike.baidu.com/searchword/?word=AA%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ **AVL树**    ▪ [红黑树](http://baike.baidu.com/view/133754.htm)    ▪ [伸展树](http://baike.baidu.com/view/1118088.htm)     ▪ [树堆](http://baike.baidu.com/searchword/?word=%E6%A0%91%E5%A0%86&pic=1&sug=1&enc=utf8)    ▪ [节点大小平衡树](http://baike.baidu.com/searchword/?word=%E8%8A%82%E7%82%B9%E5%A4%A7%E5%B0%8F%E5%B9%B3%E8%A1%A1%E6%A0%91&pic=1&sug=1&enc=utf8) |
| ---------------- | ------------------------------------------------------------ |
|                  |                                                              |

| B树  | ▪ [B树](http://baike.baidu.com/view/298408.htm)    ▪ [B+树](http://baike.baidu.com/view/1168762.htm)    ▪ [B*树](http://baike.baidu.com/view/1605516.htm)    ▪ [Bx树](http://baike.baidu.com/searchword/?word=Bx%E6%A0%91&pic=1&sug=1&enc=utf8)     ▪ [UB树](http://baike.baidu.com/searchword/?word=UB%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [2-3树](http://baike.baidu.com/view/1668085.htm)    ▪ [2-3-4树](http://baike.baidu.com/view/1995382.htm)    ▪ [(a,b)-树](http://baike.baidu.com/searchword/?word=%28a%2Cb%29-%E6%A0%91&pic=1&sug=1&enc=utf8)     ▪ [Dancing tree](http://baike.baidu.com/searchword/?word=Dancing%20tree&pic=1&sug=1&enc=utf8)    ▪ [H树](http://baike.baidu.com/searchword/?word=H%E6%A0%91&pic=1&sug=1&enc=utf8) |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

| Trie | ▪ [前缀树](http://baike.baidu.com/searchword/?word=%E5%89%8D%E7%BC%80%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [后缀树](http://baike.baidu.com/view/117678.htm)    ▪ [基数树](http://baike.baidu.com/searchword/?word=%E5%9F%BA%E6%95%B0%E6%A0%91&pic=1&sug=1&enc=utf8) |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

| 空间划分树 | ▪ [四叉树](http://baike.baidu.com/view/2063378.htm)    ▪ [八叉树](http://baike.baidu.com/view/1035343.htm)    ▪ [k-d树](http://baike.baidu.com/view/8668561.htm)    ▪ [vp-树](http://baike.baidu.com/searchword/?word=vp-%E6%A0%91&pic=1&sug=1&enc=utf8)     ▪ [R树](http://baike.baidu.com/view/906563.htm)    ▪ [R*树](http://baike.baidu.com/searchword/?word=R%2A%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [R+树](http://baike.baidu.com/searchword/?word=R%2B%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [X树](http://baike.baidu.com/searchword/?word=X%E6%A0%91&pic=1&sug=1&enc=utf8)     ▪ [M树](http://baike.baidu.com/searchword/?word=M%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [线段树](http://baike.baidu.com/view/670683.htm)    ▪ [希尔伯特R树](http://baike.baidu.com/searchword/?word=%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9R%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [优先R树](http://baike.baidu.com/searchword/?word=%E4%BC%98%E5%85%88R%E6%A0%91&pic=1&sug=1&enc=utf8) |
| ---------- | ------------------------------------------------------------ |
|            |                                                              |

| 非二叉树 | ▪ [Exponential tree](http://baike.baidu.com/searchword/?word=Exponential%20tree&pic=1&sug=1&enc=utf8)    ▪ [Fusion tree](http://baike.baidu.com/searchword/?word=Fusion%20tree&pic=1&sug=1&enc=utf8)    ▪ [区间树](http://baike.baidu.com/searchword/?word=%E5%8C%BA%E9%97%B4%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [PQ tree](http://baike.baidu.com/searchword/?word=PQ%20tree&pic=1&sug=1&enc=utf8)     ▪ [Range tree](http://baike.baidu.com/searchword/?word=Range%20tree&pic=1&sug=1&enc=utf8)    ▪ [SPQR tree](http://baike.baidu.com/searchword/?word=SPQR%20tree&pic=1&sug=1&enc=utf8)    ▪ [Van Emde Boas tree](http://baike.baidu.com/searchword/?word=Van%20Emde%20Boas%20tree&pic=1&sug=1&enc=utf8) |
| -------- | ------------------------------------------------------------ |
|          |                                                              |

| 其他类型 | ▪ [堆](http://baike.baidu.com/view/249120.htm)    ▪ [散列树](http://baike.baidu.com/searchword/?word=%E6%95%A3%E5%88%97%E6%A0%91&pic=1&sug=1&enc=utf8)    ▪ [Finger tree](http://baike.baidu.com/searchword/?word=Finger%20tree&pic=1&sug=1&enc=utf8)    ▪ [Metric tree](http://baike.baidu.com/searchword/?word=Metric%20tree&pic=1&sug=1&enc=utf8)     ▪ [Cover tree](http://baike.baidu.com/searchword/?word=Cover%20tree&pic=1&sug=1&enc=utf8)    ▪ [BK-tree](http://baike.baidu.com/searchword/?word=BK-tree&pic=1&sug=1&enc=utf8)    ▪ [Doubly-chained tree](http://baike.baidu.com/searchword/?word=Doubly-chained%20tree&pic=1&sug=1&enc=utf8)    ▪ [iDistance](http://baike.baidu.com/searchword/?word=iDistance&pic=1&sug=1&enc=utf8)     ▪ [Link-cut tree](http://baike.baidu.com/searchword/?word=Link-cut%20tree&pic=1&sug=1&enc=utf8)    ▪ [树状数组](http://baike.baidu.com/view/1420784.htm) |
| -------- | ------------------------------------------------------------ |
|          |                                                              |





### 字典树

//todo

https://mp.weixin.qq.com/s/oEXO74ko6oDGwfvXC8IVfw

## 跳表（skiplist）

https://mp.weixin.qq.com/s/4lg5RtGieuLvsbv5wAKDqQ



[漫画算法：什么是跳跃表？](http://blog.jobbole.com/111731/)



## LRU

[一文讲透Redis里面也在使用的LRU缓存算法！](https://mp.weixin.qq.com/s/mxCtce_PtNzYzUb80TDpKg)



# 排序

|          | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 是否稳定 |
| -------- | -------- | -------- | -------- | ---------- | -------- |
| 直接插入 | n        | n^2      | n^2      | 1          | 是       |
| 冒泡     | n        | n^2      | n^2      | 1          | 是       |
| 简单选择 | n^2      | n^2      | n^2      | 1          | 否       |
| 希尔     |          |          |          | 1          | 否       |
| 快排     | nlog2n   | nlog2n   | n^2      | nlog2n     | 否       |
| 堆排     | nlog2n   | nlog2n   | nlog2n   | 1          | 否       |
| 2-路归并 | nlog2n   | nlog2n   | nlog2n   | n          | 是       |
| 基数排序 | d(n + r) | d(n + r) | d(n + r) | r          | 是       |



稳定意味着什么？

> 1. 如果只是简单的进行数字的排序，那么稳定性将毫无意义。
> 2. 如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义
> 3. 如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。
> 4. 除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。（当然，如果需求不需要保持初始的排序意义，那么使用稳定性算法依旧将毫无意义）。
>
> https://www.cnblogs.com/tigerson/p/7156648.html



## TimSort

//todo





## 双轴快速排序

// todo





## 归并

一般来说是二路归并

> #### [图解排序算法(四)之归并排序](https://www.cnblogs.com/chengxiao/p/6194356.html)

这里主要是记一下时间复杂度是$nlogn$，可以简单的记忆特例的情况。

```
          n
       /    \
     n/2     n/2
    /  \      /  \
  n/4   n/4   n/4   n/4
  / \   / \   / \   / \
 n/8 n/8 n/8 n/8 n/8 n/8 n/8 n/8
```

归并分为分治的过程，先分成一个二叉树，然后每层都会遍历所有的节点。

树高logn，每层加起来都是n，一共是nlogn，上面是n为2的幂时的特殊情况。



这里理解起来有点问题的地方在于，在使用二分查找的时候，查找的路径长度为树高，所以是logn。

// Todo 而这里怎么理解呢？

```java
public class MergeSort {
    public static void main(String []args){
        int []arr = {9,8,7,6,5,4,3,2,1};
        sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    public static void sort(int []arr){
        int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间
        sort(arr,0,arr.length-1,temp);
    }
    private static void sort(int[] arr,int left,int right,int []temp){
        if(left<right){
            int mid = (left+right)/2;
            sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序
            sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序
            merge(arr,left,mid,right,temp);//将两个有序子数组合并操作
        }
    }
    private static void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i = left;//左序列指针
        int j = mid+1;//右序列指针
        int t = 0;//临时数组指针
        while (i<=mid && j<=right){
            if(arr[i]<=arr[j]){
                temp[t++] = arr[i++];
            }else {
                temp[t++] = arr[j++];
            }
        }
        while(i<=mid){//将左边剩余元素填充进temp中
            temp[t++] = arr[i++];
        }
        while(j<=right){//将右序列剩余元素填充进temp中
            temp[t++] = arr[j++];
        }
        t = 0;
        //将temp中的元素全部拷贝到原数组中
        while(left <= right){
            arr[left++] = temp[t++];
        }
    }
}
```



## ※  快速排序

快速排序是一种分治的排序算法。他将一个数组分成两个子数组，将两部分独立的排序。当两个子数组都有序时，整个数组就有序了。



```java
public class Quick{
    private static void sort(Comparable a[], int lo, int hi){
        if(hi <= lo) return;
        int j = partition(a, lo, hi); //切分
        sort(a, lo, j - 1);
        sort(a, j + 1, hi);
    }
    
    private static int partition(Comparable a[], int lo, int hi){
        int i = lo, j = hi + 1;
        Comparable v = a[lo];
        
        while(true){
            while(less(a[++i], v)){
                if(i == hi) break;
            }
            
            while(less(v, a[--j])){
                if(j == lo) break;
            }
            
            if(i >= j) {
                break;
            }
            
            exch(a, i, j);
        }
        
        exch(a, lo, j);
        return j;
    }
}
```



- 首先随意的选`a[lo]`作为切分元素，即那个将会被排定的元素
- 然后从数组的左端开始向右端扫描直到找到一个**大于等于**它的元素
- 再从数组的右端向左端扫描直到找到一个**小于等于**它的元素
- 这两个元素显然是没有排定的，那么交换他们的位置
- 当两个指针相遇时，我们只需要将切分的元素`a[lo]`和左子数组最右侧的元素`a[j]`，交换，然后返回下标j。

这里要记忆的地方是边界情况，在对比时如果是等于，也是需要交换的。原因见`p185页2.3.1.5 处理切分元素值有重复的情况`。



这样保证了

- 对于某个j，a[j]已经排定了
- a[lo]到a[j - 1]中的所有元素都**不大于**a[j]
- a[j + 1]到a[hi]中的所有元素都**不小于**a[j]



再来一个可以运行的版本

```java
public class QuickSortInt {

    public static void main(String[] args) {
        QuickSortInt quickSortInt = new QuickSortInt();
        int[] a = new int[]{3, 5, 1, 2, 3, 5, 4, 4};
        quickSortInt.sort(a, 0, a.length - 1);
        for (int i : a) {
            System.out.println(i);
        }
    }

    public void sort(int[] a, int lo, int hi){
        if (lo >= hi) return;
        int j = partition(a, lo, hi);
        sort(a, lo, j - 1);
        sort(a, j + 1, hi);
    }

    private int partition(int[] a, int lo, int hi) {
        int i = lo;
        int j = hi + 1;
        int v = a[lo];
        while (true){
            while (less(a[++i], v)){
                if (i == hi) break;
            }
            while (less(v, a[--j])){
                if (j == lo) break;;
            }

            if (i >= j){
                break;
            }
            exch(a, i, j);
        }
        exch(a, lo, j);
        return j;
    }

    private void exch(int[] a, int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private boolean less(int i, int v) {
        return i < v;
    }
}
```



> #### 性能分析

- 最好情况
- 最坏情况
- 平均复杂度



 **算法改进**

> #### 改插入排序

对于小数组，快速排序比插入排序慢。



> #### 三取样切分

使用子数组的一小部分的元素的中位数来切分数组。这样做得到的切分更好，但代价是需要计算中位数。



> #### 熵最优的排序

一个简单的想法是将数组切为三部分，分别对应小于，等于和大于切分元素的数组元素。



三向切分的快速排序

```java
public class Quick3way{
    private static void sort(Comparable a[], int lo, int hi){
        if(hi <= lo) return;
        
        int lt = lo, i = lo + 1, gt = hi;
        Comparable v = a[lo];
        while(i <= gt){
            int cmp = a[i].compareTo(v);
            if(cmp < 0){
                exch(a, lt++, i++);
            }else if(cmp > 0){
                exch(a, i, gt--);
            }else{
                i++;
            }
        }
        
        sort(a,  lo, lt - 1);
        sort(a, gt + 1, hi);
    }
}
```







## 优先队列（堆排序）

优先队列由一个基于堆的完全二叉树表示，优先队是一种数据结构，他支持两种操作：删除最大元素和插入元素。

实现优先队列有多种数据结构可以选择：

- 使用无序数组实现
- 使用有序数组实现
- 使用链表（二叉树）
- 使用堆



优先队列各种实现在最坏情况下的时间

| 数据结构 | 插入元素 | 删除最大元素 |
| -------- | -------- | ------------ |
| 有序数组 | N        | 1            |
| 无序数组 | 1        | N            |
| 堆       | logN     | logN         |
| 理想情况 | 1        | 1            |



这里涉及到一个二叉堆的数据结构。

> #### 二叉堆

二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）



**基于堆的优先队列**API：

```java
public class MaxPQ<Key extends Comparable<Key>>{
    private Key[] pq;
    private int N = 0;
    
    //……省略构造和getter、setter
    
    public void insert(key v){
        pq[++N] = v;
        swim(N);
    }
    
    public Key delMax(){
        Key max = pq[1];
        exch(1, N--);
        pq[N + 1] = null;
        sink(1);
        return max;
    }
    
    private boolean less(int i, int j){
        return pq[i].compareTo(pq[j]) < 0;
    }
    
    private void exch(int i, int j){
        key t = pq[i];
        pq[i] = pq[j];
        pq[j] = t;
    }
    
    //上浮
    private void swim(int k){
        while(k > 1 && less((k / 2), k)){
            exch(k / 2, k);
            k = k /2;
        }
    }
    
    //下沉
    private void sink(int k){
        while(k * 2 <= N){
            int j = k * 2;
            if(j < N && less(j, j + 1)){
                j++;
          	}
            
            if(!less(k, j)){
               break;
            }
            exch(k, j);
            k = j;
        }
    }
}
```



> #### 堆排序

将所有元素插入一个查找最小元素的优先队列，然后重复调用删除最小元素的操作来将他们按顺序删去。



```java
public static void sort(Comparable[] a){
    int N = a.length;
    for(int k = N / 2; k >= 1; k --){
        sink(a, k, N);
    }
    
    while(N > 1){
        exch(a, 1, N--);
        sink(a, 1, N);
    }
}
```

for循环构造了一个堆，while中把头和尾进行交换并修复堆，当N = 0时，排序就完成了。



> #### 数据流中的第K大元素

LeetCode 703. [数据流中的第K大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

思路：

- 方法—：需要第K大，使用优先队列构造一个小顶堆，堆的大小为K。
- 方法二：排序。预留长度为K的数组，每次进来一个数先排序，干掉多出来的最小的那一个。排序一般用快排（logn），所以时间复杂度为nlogn



## 外部排序

掌握利用内存和外部存储处理超大数据集，至少要理解过程和思路。

hadoop？wordCount？






# 图

## 无向图

### ※ 深度优先搜索

```python
// 递归写法
visited = set()
def dfs(node, visited):
  visited.add(node)
  # do something
  .....
  for next_node in node.children():
    if not next_node in visited:
      dfs(next_node, visited)
```



N皇后

```python
def solveNQueens(self, n):
  if n < 1:return []
  self.result = []
  self.cols = set(); self.pie = set(); self.na = set()
  self.DFS(n, 0, [])
  return self._generate_result(n)

def DFS(self, n, row, cur_state):
  if row >= n:
    self.result.append(cur_state)
    return
  
  for col in rang(n):
    if col in self.cols or row + col in self.pie or row - col in self.na
    continue
    
    self.cols.add(col)
    self.pie.add(row + col)
    self.na.add(row - col)
    self.DFS(n, row + 1, cur_state + [col])
    self.cols.remove(col)
    self.pie.remove(row + col)
    self.na.remove(row - col)
    
    
 def _generate_result(self, n):
  board = []
  for res in self.result:
    for i in res:
      board.append("." * i + "Q" + "." * (n - i - 1))
      
  return [board[i: i + n]] for  i in range(0, len(board), n)
```







### ※ 广度优先搜索

```python
def BFS(graph, start, end):
  queue = []
  queue.append([start])
  visited.add(start)
  
  while queue:
    node = queue.pop()
    visited.add(node)
    
    process(node)
    node = generate_ralated_nodes(node)
    queue.push(nodes)
    
    ......
```





## 有向图



## 最小生成树

## 最短路径



# 字符串

## 引用

强烈推荐这位老哥的文章，写的非常易懂。

[字符串算法—字符串排序（上篇）](https://www.cnblogs.com/mcomco/p/10349996.html)

[字符串算法—字符串排序（下篇）](https://www.cnblogs.com/mcomco/p/10366184.html)



## 字符串排序

### 键索引计数法

假设Person 有组号与姓名两个属性，需要按组号从小到大把这些人排序

| 姓名   | 组号 |
| ------ | ---- |
| 张三   | 2    |
| 李四   | 3    |
| 王五   | 3    |
| 赵六   | 2    |
| 汲春雪 | 1    |
| 愈从阳 | 2    |
| 海丹红 | 1    |



```java
// 记录所有人的数组a[]
a[];
// 张三
a[1].name();
// 1
a[1].key();

// 统计每个组号出现的频率的数组count[]
count[];

// 如果组号（键）为r，则把count[r + 1]的值自增1（r + 1的原因？），则
// 组-1，默认0
count[0] = 0; 
// 组（键）0
count[1] = 0; 
// 组（键）1
count[2] = 2; 
// 组（键）2
count[3] = 3;
// 组（键）3
count[4] = 2;

```



这时将频率数组count[]转化成起始索引数组cont[]。书中使用了同一个数组，为了更好的区分，这里使用一个新的数组cont[]。

对于每个键值r，小于r+1的键的频率之和 = 小于r的键的频率之和 + r的键的频率之和（count[r+1]）。

小于3的键频率之和 = 小于2的键频率之和 + count[3] = 小于1的键频率之和 + count[2] + count[3] = 5 

​								= 第三组在最后索引中的起始位置。

|       | cont[0] | cont[1] | cont[2] | cont[3] | cont[4] |
| ----- | ------- | ------- | ------- | ------- | ------- |
| 小于0 | 0       |         |         |         |         |
| 小于1 |         | 0       |         |         |         |
| 小于2 |         |         | 2       |         |         |
| 小于3 |         |         |         | 5       |         |
| 小于4 |         |         |         |         | 7       |

```java
cont[0] = 0;
cont[1] = 0;
cont[2] = 2;
cont[3] = 5;
cont[4] = 7;

// 回顾表中a[]
a[0].key = 2;
a[1].key = 3;
a[2].key = 3;
a[3].key = 2;
a[4].key = 1;
a[5].key = 2;
a[6].key = 1;
```



之后将所有人移到一个辅助数据aux[]中进行排序

```java
for(int i = 0; i < R; i++){
  aux[cont[a[i].key()]++] = a[i];
}

aux[cont[a[0].key()]++] = aux[cont[2]++] = aux[2] = a[0];       // cont[2] = cont[2] + 1 = 3
aux[cont[a[1].key()]++] = aux[cont[3]++] = aux[5] = a[1];       // cont[3] = cont[3] + 1 = 6
aux[cont[a[2].key()]++] = aux[cont[3]++] = aux[6] = a[2];       // cont[3] = 6 + 1 = 7

aux[cont[a[3].key()]++] = aux[cont[2]++] = aux[3] = a[3];       // cont[2] = 3 + 1 = 4
aux[cont[a[4].key()]++] = aux[cont[1]++] = aux[0] = a[4];       // cont[1] = cont[1] + 1 = 1
aux[cont[a[5].key()]++] = aux[cont[2]++] = aux[4] = a[5];       // cont[2] = 4 + 1 = 5
aux[cont[a[6].key()]++] = aux[cont[1]++] = aux[1] = a[6];       // cont[2] = 1 + 1 = 2

```



| aux[0] | aux[1] | aux[2] | aux[3] | aux[4] | aux[5] | aux[6] |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 汲春雪 | 海丹红 | 张三   | 赵六   | 愈从阳 | 李四   | 王五   |
| a[4]   | a[6]   | a[0]   | a[3]   | a[5]   | a[1]   | a[2]   |
| 1      | 1      | 2      | 2      | 2      | 3      | 3      |



- 主要的思路是分段，确定每一段有多少个数字，思路类似基数排序中的桶子。

- 使用数组的方式可以直接读写指定位置的值（随机存取）

- 如果组号（键）为r，则把count[r + 1]的值自增1。r + 1的原因是

  ```java
  	// 如果考虑使用同一个count数组则
  	for(int r = 0; r < R; r++){
      count[r + 1] += count[r];
    }
  ```

  在这个地方，不用进行-1补正。这句话的意思是：组号为r+1的起始位置是 = 组号为r的个数（count[r+1]） + 组号为r的起始位置(count[r])。此时的count[r]已经被复写代表的是起始位置也就是索引，而count[r + 1]代表的仍然是频率也就是个数。



完整的代码表述为

```java
int N = a.length;

String[] aux = new String[N];
int [] count = new int[R + 1];

// 计算出现频率
for(int i = 0; i < N; i++){
  count[a[i].key() + 1]++;
}

// 将频率转换为索引
for(int r = 0; r < R; r++){
  count[r + 1] += count[r];
}

// 将元素分类
for (int i = 0; i < N; i ++){
  aux[count[a[i].key()]++] = a[i];
}

// 回写
for(int i = 0; i < N; i++){
  a[i] = aux[i];
}
```



复杂度

> 键索引计数法排序N个键为0到R-1之间的整数的元素需要访问数组11N + 4R + 1次。
>
> 证明：
>
> 初始化数组会访问数组N+R=1次。
>
> 第一次循环中，N个元素均会使计数器的值+1(访问数组2N次)；
>
> 第二次循环会进行R次加法（访问数组2R次）；
>
> 第三次循环会使计数器的值增大N次并移动N次数据（访问数组3N次）；
>
> 第四次循环会移动数据N次（访问数组2N次）。



他是一个稳定的算法。



### 低位优先的字符串排序



### 高位优先的字符串排序



### 三向字符串快速排序





## 单词查找



### 单词查找树



### 三向单词查找树







## 子字符串查找

### Knuth-Morris-Pratt(KMP)

这个是本文最难理解的基本算法，在理解了他的前提下，后续的BM那都不是事。

目前为止，看到了3种思路，分别是

- 仓鼠哥的next数组到nextVal，也就是kmp到kmp进阶。
- 算法哥与《算法》版
- 课本天勤版



分别理解三版，有助于面对面试时的花式考察。









### Boyer-Moore



### Rabin-Karp







## 正则表达式

## 数据压缩



# 动态规划



> #### LeetCode 152. [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)

计算最大乘积，顺着例子比较容易想到的是滑动窗口，把他和dp放在一起有点牵强。本题我放弃了，直接上评论区第一的代码

```java
int maxProduct(int A[], int n) {
    // store the result that is the max we have found so far
    int r = A[0];

    // imax/imin stores the max/min product of
    // subarray that ends with the current number A[i]
    for (int i = 1, imax = r, imin = r; i < n; i++) {
        // multiplied by a negative makes big number smaller, small number bigger
        // so we redefine the extremums by swapping them
        if (A[i] < 0)
            swap(imax, imin);

        // max/min product for the current number is either the current number itself
        // or the max/min by the previous number times the current one
        imax = max(A[i], imax * A[i]);
        imin = min(A[i], imin * A[i]);

        // the newly computed max value is a candidate for our global result
        r = max(r, imax);
    }
    return r;
}
```



- 由于数组中可能会出现负数，所以需要一个imin变量来保存最小的。
- 核心逻辑`max(A[i], imax * A[i]);`，当加了一个数的积与加的这个数本身进行比较，如果最后的积小于加的这个数本身，那么舍去前面的全部，重新开始计算。为什么这里可以舍去前面的全部？而不是舍去之前数组的第一个数呢？为什么这个这个指针是可以不用回溯的呢？朴素的按经验来看，每一次的遍历都保证了局部最优，那么如果出现了新乘了一个数，积反而更小了的情况，那么一定是新乘的这个数有问题，所以无论从头出删除多少个数都没用。但是这个应该还是要一个明确的数学上的证明，可惜的是目前为止，还没有找到





> #### LeetCode [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

非常经典的DP入门题，如果使用常规的递归，则会超出时间限制

```java
  public int climbStairs(int n) {
    if(n == 1) return 1;
    if(n == 2) return 2;
    return climbStairs(n - 1) + climbStairs(n - 2);
  }
```



使用DP的初版写法，这个版本的逻辑是最为清晰的。

```java
    public int climbStairs(int n) {
        int [] dp = new int[n + 1];
        if(n == 1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        
        for(int i = 3; i <= n; i++){
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
```

但是如果细看的话，其实我们根本就不需要一个数组，只要维护2个临时变量就可以了。



> #### LeetCode [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

经典的DP题目，需要注意的点是需要处理好边界问题，第一行与第一列需要特殊处理一下。

```java
 		public int minPathSum(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        int[][] dp = new int[row][col];
        dp[0][0] = grid[0][0];
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(i == 0 && j > 0){
                    dp[0][j] = dp[0][j - 1] + grid[0][j];
                }

                if(j == 0 && i > 0){
                    dp[i][0] = dp[i - 1][0] + grid[i][0];
                }

                if(i > 0 && j > 0){
                    dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
                }
            }
        }
        return dp[row - 1][col - 1];
    }
```



> #### LeetCode [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

正常人都是从上往下去推，所以需要加很多的边界

```java
    public int minimumTotal(List<List<Integer>> triangle) {
        Integer[][] dp = new Integer[triangle.size() + 1][triangle.size() + 1];
        for (int i = 1; i <= triangle.size(); i++) {
            List<Integer> row = triangle.get(i - 1);
            for (int j = 1; j <= row.size(); j++) {
                Integer right = dp[i - 1][j];
                Integer left = dp[i - 1][j - 1];
                int parent;
                if (left != null && right != null) {
                    parent = Math.min(right, left);
                } else if (left != null) {
                    parent = left;
                } else if (right != null) {
                    parent = right;
                } else {
                    parent = 0;
                }
                dp[i][j] = parent + row.get(j - 1);
            }
        }

        int sum = dp[triangle.size()][1];
        for (int j = 2; j < triangle.size() + 1; j++) {
            sum = Math.min(sum, dp[triangle.size()][j]);
        }
        return sum;
    }
```



而评论区的都是从下往上推，中间值存在数组里面，思路清奇。

```java
 public int minimumTotal(List<List<Integer>> triangle) {
		if(triangle.size() == 0)
			return 0;
		
		for (int i=triangle.size() - 2; i>=0; i--) {
			for (int j=0; j<=i; j++) {
				List<Integer> nextRow = triangle.get(i+1);
				int sum = Math.min(nextRow.get(j), nextRow.get(j+1)) + triangle.get(i).get(j);
				triangle.get(i).set(j, sum);
			}
		}
		return triangle.get(0).get(0);
	}

https://leetcode.com/problems/triangle/discuss/38730/DP-Solution-for-Triangle
https://leetcode.com/problems/triangle/discuss/38730/DP-Solution-for-Triangle/36542
```





# 贪心算法







# 常见问题

## 背包问题

有N件物品和一个容量为V的背包。第i件物品的价格（即体积，下同）是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

蛮力法、动态规划法、回溯法和分支限界法求解



[本周算法：背包问题](http://www.importnew.com/13072.html)





- **二分查找法**。一般面试官会要求面试者把算法写出来，或者先结合一个具体场景来提问，需要你联想到要使用该算法，比如求一个数的平方根，接着要你把它具体实现。



# 面试题

腾讯音乐

一面

单链表，奇数节点递增，偶数节点递减，如何得到一条有序的链表？

```java
    public static ListNode revert(ListNode node) {
        if (node == null) return null;

        ListNode odd = new ListNode(-1);
        ListNode even = new ListNode(-1);
        ListNode oddHead = odd;
        ListNode evenHead = even;

        ListNode current = node;
        int i = 1;
        while (current != null) {
            if (i % 2 == 1) {
                odd.next = current;
                odd = odd.next;
            } else {
                even.next = current;
                even = even.next;
            }
            current = current.next;
            i++;
        }
        even.next = null;
        odd.next = null;

        // 反转链表
        ListNode pre = null;
        current = evenHead.next;
        if (current != null){
            while (true) {
                ListNode next = current.next;
                current.next = pre;
                pre = current;
                if (next == null) break;
                current = next;
            }
        }

        evenHead = current;
        ListNode head = new ListNode(-1);
        ListNode tmp = head;
        oddHead = oddHead.next;

        if (evenHead == null){
            head.next = oddHead;
        }else {
            while (true) {
                int valOdd = oddHead.val;
                int valEven = evenHead.val;

                if (valOdd > valEven) {
                    tmp.next = evenHead;
                    evenHead = evenHead.next;
                } else {
                    tmp.next = oddHead;
                    oddHead = oddHead.next;
                }

                tmp = tmp.next;
                if (evenHead == null) {
                    tmp.next = oddHead;
                    break;
                }

                if (oddHead == null) {
                    tmp.next = pre;
                    break;
                }
            }
        }

        return head.next;
    }

    public static void main(String[] args) {
        ListNode node1 = new ListNode(1);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(3);
        ListNode node4 = new ListNode(4);
        ListNode node5 = new ListNode(5);
        ListNode node6 = new ListNode(6);
        ListNode node7 = new ListNode(7);

        node1.next = node7;
        node7.next = node2;
        node2.next = node6;
        node6.next = node3;
        node3.next = node5;
        node5.next = node4;
        
        ListNode revert = revert(node1);
        while (true) {
            System.out.println(revert.val);
            revert = revert.next;
            if (revert == null) break;
        }
    }
```



