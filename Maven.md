# 生命周期

有三个内置的生命周期：**默认（default）**，**清洁（clean）**和**站点（site）**。在**默认（default）**的生命周期处理你的项目部署，将**清洁（clean）**的生命周期处理项目的清理，而**网站（site）**的生命周期处理你的项目站点文档的创建。



**默认（default）**的生命周期包括以下阶段（注意：这里是简化的阶段）

- **验证（validate）** - 验证项目是否正确，所有必要的信息可用
- **编译（compile）** - 编译项目的源代码
- **测试（test）** - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署
- **打包（package）** - 采用编译的代码，并以其可分配格式（如JAR）进行打包。
- **验证（verify）** - 对集成测试的结果执行任何检查，以确保满足质量标准
- **安装（install）** - 将软件包安装到本地存储库中，用作本地其他项目的依赖项
- **部署（deploy）** - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享。



[Maven的构建生命周期理解](https://www.cnblogs.com/EasonJim/p/6816340.html)



# 常用命令

- Maven build是这个插件让你自己去配置执行目标的。
- Maven clean 清除上一次Maven执行的结果
- Maven generate-sources会根据pom配置去生成源代码格式的包
- Maven install将项目输出构件部署到本地仓库



# 依赖冲突

maven在依赖冲突管理中有一下几个原则：

1. 依赖是使用Maven坐标来定位的，而Maven坐标主要由GAV（groupId, artifactId, version）构成。如果两个相同的依赖包，如果groupId, artifactId, version不同，那么maven也认为这两个是不同的。
2. 依赖会传递，A依赖了B，B依赖了C，那么A的依赖中就会出现B和C。
3. Maven对同一个groupId, artifactId的冲突仲裁，不是以version越大越保留，而是依赖路径越短越优先，然后进行保留。
4. 依赖的scope会影响依赖的影响范围。



**仲裁过程**

对于依赖某个组件的多个版本，maven的仲裁过程，并不是简单的使用高版本，而是根据从根节点到各个组件节点之间的路径深度，路径短的组件优先，如果路径深度相同，则是先发现的那个。类似一棵树的广度遍历。

如果两条路都是一样长的时候呢？看Classloader的加载顺序了，假设Classloader先加载X_1.0，而它就不会再加载X_2.0了。