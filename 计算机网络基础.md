# 综述

大量参考《趣谈协议》



按照不同的标准可以分为7层模型与5层模型，其中主要的协议如图

![image-20210210125307182](截图/计算机网络/网络协议模型.png)



一个非常形象的流程图，把请求中主要的协议功能都展示出来了。

# 发送流程

![index](截图/计算机网络/请求流程图.jpg)

# 物理层

> #### 集线器(hub)

它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。



# 数据链路层

也即 MAC 层要解决的问题。**MAC**的全称是**Medium Access Control**，即**媒体访问控制。**

主要解决

1. 这个包是发给谁的？谁应该接收？
2. 大家都在发，会不会产生混乱？有没有谁先发、谁后发的规则？（**多路访问**的堵车问题）
3. 如果发送的时候出现了错误，怎么办？



> #### 多路访问方式

- 方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作**信道划分；**
- 方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作**轮流协议；**
- 方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作**随机接入协议。**著名的以太网，用的就是这个方式。



> #### 发给谁，谁接收？

物理地址，叫作**链路层地址。**但是因为第二层主要解决媒体接入控制的问题，所以它常被称为**MAC 地址**。

第二层的网络包格式如下图

![index](截图/计算机网络/数据帧结构.jpg)

对于以太网，第二层的最开始，就是目标的 MAC 地址和源的 MAC 地址。接下来是**类型**，大部分的类型是 IP 数据包，然后 IP 里面包含 TCP、UDP，以及 HTTP 等，这都是里层封装的事情。

有了这个目标 MAC 地址，数据包在链路上广播，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80，而 nginx 就是监听 80。



> #### 数据校验

对于以太网，第二层的最后面是**CRC**，也就是**循环冗余检测**。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误。

//todo 待解释CRC细节



> #### 交换机

Hub 是广播的，不管某个接口是否需要，所有的 Bit 都会被发送出去，然后让主机来判断是不是需要。这种方式路上的车少就没问题，车一多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费。交换机把MAC 头拿下来，检查一下目标 MAC 地址，然后根据策略转发。

**工作原理**

一台 MAC1 电脑将一个包发送给另一台 MAC2 电脑，当这个包到达交换机的时候，一开始交换机也不知道 MAC2  的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。这个时候交换机会记住，MAC1 是来自一个明确的口。以后有包的目的地址是 MAC1 的，直接发送到这个口就可以了。

当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。当然，每个机器的 IP 地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为**转发表**，是有一个过期时间的。



## ARP 协议

已知 IP 地址，求 MAC 地址的协议。

在一个局域网里面，当知道了 IP 地址，不知道 MAC 怎么办呢？广而告之，发送一个广播包，谁是这个 IP 谁来回答。为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。

整个流程如下：

![index](截图/计算机网络/ARP请求流程图.jpg)



具体询问和回答的报文就像下面这样：

![index](截图/计算机网络/ARP报文.jpg)





# DHCP

> 第04讲丨DHCP与PXE：IP是怎么来的，又是怎么没的？

**动态主机配置协议（Dynamic Host Configuration Protocol）**，简称**DHCP**

> #### 解析 DHCP 的工作方式

**DHCP Discover。**

新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了  UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。在这个广播包里面，新人大声喊：我是新来的（Boot request），我的 MAC 地址是这个，我还没有 IP，谁能给租给我个 IP 地址！

Boot request 结构

![index](截图/计算机网络/DHCP包结构.jpg)



**DHCP Offer**

如果一个网络管理员在网络里面配置了**DHCP Server**的话，立刻能知道来了一个“新人”。由于MAC 唯一，IP 管理员知道这是一个新人，需要租给它一个 IP 地址，这个过程我们称为**DHCP Offer**。同时，DHCP Server 为此客户保留为它提供的 IP 地址，从而不会为其他 DHCP 客户分配此 IP 地址。

DHCP Offer 的格式就像这样，里面有给新人分配的地址。

![index](截图/计算机网络/DHCP Offer格式.jpg)

DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。除此之外，服务器还发送了子网掩码、网关和 IP 地址租用期等信息。

如果有多个 DHCP Server，这台新机器会收到多个 IP 地址。它会选择其中一个 DHCP Offer，一般是最先到达的那个，并且会向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销它们提供的 IP 地址，以便提供给下一个 IP 租用请求者。

此时，由于还没有得到 DHCP Server 的最后确认，客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。在 BOOTP 里面，接受某个 DHCP Server 的分配的 IP。

当 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机。最终租约达成的时候，还是需要广播一下，让大家都知道。



> #### IP 地址的收回和续租

客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request  消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP  参数，更新自己的配置。这样，IP 租用更新就完成了。



# IP

![index](截图/计算机网络/IP分类.jpg)

![index](截图/计算机网络/IP分类主机数.jpg)

上面这个表格，详细地展示了 A、B、C 三类地址所能包含的主机的数量。



> #### 无类型域间选路（CIDR）

由于C类地址实在太少，于是有了一个折中的方式叫作**无类型域间选路**，简称**CIDR**。这种方式打破了原来设计的几类地址的做法，将 32 位的 IP 地址一分为二，前面是**网络号**，后面是**主机号**。从哪里分呢？你如果注意观察的话可以看到，10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。

伴随着 CIDR 存在的，一个是**广播地址**，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。另一个是**子网掩码**，255.255.255.0。

将子网掩码和 IP 地址进行 AND 计算。前面三个 255，转成二进制都是 1。1 和任何数值取  AND，都是原来数值，因而前三个数不变，为 10.100.122。后面一个 0，转换成二进制是 0，0 和任何数值取 AND，都是  0，因而最后一个数变为 0，合起来就是 10.100.122.0。这就是**网络号**。**将子网掩码和 IP 地址按位计算 AND，就可得到网络号。**



> #### 多播与组播的区别

// todo



> #### 随便填一个ip会发送什么？
>
> 第04讲丨DHCP与PXE：IP是怎么来的，又是怎么没的？—— 《趣谈协议》

不会出现任何现象，就是包发不出去呗。

192.168.1.6 就在你这台机器的旁边，甚至是在同一个交换机上，而你把机器的地址设为了 16.158.23.6。在这台机器上，你企图去 ping192.168.1.6。

这个包它有自己的源 IP 地址 16.158.23.6，也有目标 IP 地址 192.168.1.6，但是包发不出去，这是因为 MAC 层还没填。自己的 MAC 地址自己知道，这个容易。但是目标 MAC 填什么呢？是不是填 192.168.1.6 这台机器的 MAC 地址呢？

当然不是。Linux 首先会判断，要去的这个地址和我是一个网段的吗，或者和我的一个网卡是同一网段的吗？只有是一个网段的，它才会发送 ARP 请求，获取 MAC 地址。如果发现不是呢？**Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。**

如果你配置了网关的话，Linux 会获取网关的 MAC 地址，然后将包发出去。对于 192.168.1.6 这台机器来讲，目标 IP 是它，但是无奈 MAC 地址不是它的，所以它的网卡是不会把包收进去的。

如果没有配置网关呢？那包压根就发不出去。如果将网关配置为 192.168.1.6 呢？不可能，Linux 不会让你配置成功的，因为网关要和当前的网络至少一个网卡是同一个网段的，怎么可能 16.158.23.6 的网关是 192.168.1.6 呢？



# TCP

TCP是在不可靠的IP层上实现的可靠的数据传输协议，它主要解决传输的**可靠、有序、无丢失和不重复问题**。

1. TCP是**面向链接**的**传输层**协议。
2. 每一条TCP连接只能有2个端点。
3. 全双工
4. 面向字节流



![TCP报文段首部](截图/计算机网络/TCP报文段首部.png)



1. **序号：**TCP是面向字节流的，传输时是按照字节一个个字节来传输的，所以需要带编号。这个字段的意思是——本报文段所发送的数据的第一个字节的序号。
2. **确认号**：期望收到对方的**下一个报文段的数据的第一个字节**的序号。
3. **确认位（ACK）**：只有当`ACK = 1 `时，确认号字段才有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置为1。
4. **同步位（SYN）**；`SYN = 1` 时表明这是一个连接请求或者连接接受报文。
   - 当`SYN = 1， ACK = 0` 时表明这是一个连接请求报文。
   - 当`SYN = 1， ACK = 1` 时表明这是一个连接接受报文。
5. **终止位（FIN）**：用来释放一个连接。`FIN = 1` 表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。



## 三次握手

![三次握手](截图/计算机网络/三次握手.png)



1. 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入**SYN_SENT**状态，等待Server确认。（连接请求不携带数据，但要消耗掉一个序号）。
2. 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入**SYN_RCVD**状态。（**这时server为该TCP连接分配TCP缓存和变量**，确认报文也不携带数据，但要消耗掉一个序号）。
3. 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，序号字段为j + 1 ，确认号字段为 ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入**ESTABLISHED**状态，完成三次握手，随后Client与Server之间可以开始传输数据了。（这时client为该TCP连接分配TCP缓存和变量）





## 四次挥手

![四次挥手](截图/计算机网络/四次挥手.jpg)



1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。



## TCP 协议如何保证可靠传输

TCP使用了校验、序号、确认和重传等机制来达到这个目的。

1. **序号：**TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 

2. **确认：**TCP默认使用累计确认，即TCP只确认数据流中至第一个丢失字节为止的字节。

3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 

4. **重传：**超时和冗余ACK都会导致重传。

   - **自动重传请求 ARQ 协议**

     停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。

     **优点：** 简单

     **缺点：** 信道利用率低

   - **连续ARQ协议**

     连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

     **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

     **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。



### TCP流量控制

1. 目的是消除发送方使接收方缓存区溢出，因此可以说流量控制是一个速度匹配服务。
2. TCP使用滑动窗口机制来实现流量控制。



### TCP拥塞控制

1. 目的是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不致过载。
2. 四种算法：慢开始、拥塞避免、快重传、快恢复。

   - **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
   - **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
   - **快重传与快恢复：**
     在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。





# UDP



# HTTP 





# HTTPS









# 请求会发生什么

![浏览器输入url经历图](截图/计算机网络/浏览器输入url经历图.jpg)



1. 用户输入url，浏览器内部代码将url进行拆分解析
2. 浏览器首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有就会将domain（域）发送给 dns进行解析，将域名解析成对应的服务器IP地址，发回给浏览器。
3. 浏览器拿到了服务器IP，接下来是网络通信，分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层往上
4. 页面的渲染阶段
   1. 解析HTML生成DOM树。
   2. 解析CSS生成CSSOM规则树。
   3. 将DOM树与CSSOM规则树合并在一起生成渲染树。
   4. 遍历渲染树开始布局，计算每个节点的位置大小信息。
   5. 将渲染树每个节点绘制到屏幕。



[浏览器的一个请求从发送到返回都经历了什么？](https://www.cnblogs.com/echo-hui/p/9298203.html)



# IP命令

> #### 怎么查看 IP 地址？

在 Windows 上是 ipconfig，在 Linux 上是 ifconfig、 ip addr，也可以自行安装 net-tools 和 iproute2 这两个工具



> #### ifconfig 和 ip addr 的区别

// todo  net-tools 和 iproute2



运行一下 ip addr

```shell
root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    	 valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
		   valid_lft forever preferred_lft forever

2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:fec7:7975/64 scope link 
       valid_lft forever preferred_lft forever
```



在 IP 地址的后面有个 scope，对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。

lo 全称是**loopback**，又称**环回接口**，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。

在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为**MAC 地址**。

<BROADCAST,MULTICAST,UP,LOWER_UP> 是干什么的？这个叫作**net_device flags**，**网络设备的状态标识**。

UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST  表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。

最大传输单元  MTU 为 1500，这是以太网的默认值。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。



qdisc pfifo_fast 

qdisc 全称是**queueing discipline**，中文叫**排队规则**。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。

最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。数据包是按照服务类型（**Type of Service，TOS**）被分配到三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。



# 面试题

> ### TCP连接阶段

- ### 发送序号和确认序号问题

  例： TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为？
  答：看答案时请参考上面TCP连接建立的图。
  客户端：发送X
  服务端：发送Y， 确认X+1
  客户端：发送X+1（1000），确认Y+1（2000）
  可以反推第二次为1999,确认1000

- ### 为什么TCP建立连接要三次握手

  1. 首先得回答三次握手的目的是**同步连接双方的序列号**和**确认号**并**交换 TCP 窗口大小信息**。
  2. 回答为什么两次握手不行，C发送请求，S应答并分配资源，若S的应答没有到达C端，C认为连接未建立，而S认为建立了，S会在一段时间内保留分配的资源，如果大量C这样请求，S会崩溃 。
  3. 最后回答握手当然可以四次五次一直握下去，但三次已经够了，就没有必要了。总结下来一句话，主要目的防止在网络发生延迟或者丢包的情况下浪费资源。



- ### 为什么断开TCP连接需要进行四次握手 

  因为TCP连接是**全双工的网络协议**，允许同时通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕，向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。所以关闭TCP连接需要进行四次握手，每次关闭一个方向上的连接需要FIN和ACK两次握手。



-  ### tcp怎么保证有序传输的

  1. 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认。
  2. 如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序**列号**对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等。
  3. 接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。



- ### 讲下tcp的快速重传和拥塞机制，

- ### 知不知道time_wait状态，这个状态出现在什么地方，有什么用？（参考quic）

  - 通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。客户端主动关闭连接时，会发送最后一个ack后，然后会进入TIME_WAIT状态，再停留2个MSL时间(后有MSL的解释)，进入CLOSED状态。

  - TCP/IP协议就是这样设计的，是不可避免的。主要有两个原因:

    - 可靠地实现TCP全双工连接的终止

      TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED  状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误（在java中会抛出connection  reset的SocketException)。

      因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态 。 

    - 允许老的重复分节在网络中消逝 

      TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。



- ### 知道udp是不可靠的传输，如果你来设计一个基于udp差不多可靠的算法，怎么设计？



- ### 既然UDP是不可靠的，有什么方法可以使得UDP变成一个可靠的传输协议？

  



- ### http与https有啥区别？说下https解决了什么问题，怎么解决的？说下https的握手过程。

  - HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
  - HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层（Secure Sockets Layer 安全套接层），HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

  　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。



[TCP为什么要三次握手，不是两次四次？](http://blog.chinaunix.net/uid-20726927-id-2455485.html)

[为什么建立TCP连接需要三次握手，为什么断开TCP连接需要四次握手，TIME_WAIT状态的意义](https://www.cnblogs.com/zhoudayang/p/6012257.html)

[tcp窗口滑动以及拥塞控制](https://www.cnblogs.com/woaiyy/p/3554182.html)





> #### http 响应码 301 和 302 代表的是什么？有什么区别？

301 redirect: 301 代表永久性转移(Permanently Moved)。
302 redirect: 302 代表暂时性转移(Temporarily Moved )。 

[HTTP返回码中301与302的区别](https://blog.csdn.net/qmhball/article/details/7838989)



> #### 如何实现跨域？



> #### 说一下 JSONP 实现原理？